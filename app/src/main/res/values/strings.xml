<resources>
    <string name="app_name">Mini_Project</string>


    <string name="topics_tv1">Android \nIntroduction</string>
    <string name="topics_tv2">Android\nArchitecture</string>
    <string name="topics_tv3">Android\n IDE</string>
    <string name="topics_tv4">Android\nComponents</string>
    <string name="topics_tv5">Manifest\nFile</string>
    <string name="topics_tv6">Activities</string>
    <string name="topics_tv7">Fragment</string>
    <string name="topics_tv8">Android\nIntent</string>
    <string name="topics_tv9">Services</string>
    <string name="topics_tv10">Resources</string>
    <string name="topics_tv11">UI \n Layouts</string>
    <string name="topics_tv12">UI \n Widgets</string>
    <string name="topics_tv13">Android \nMenu</string>
    <string name="topics_tv14">Broadcast\nReceivers</string>
    <string name="topics_tv15">Content\nProvider</string>
    <string name="topics_tv16">Containers</string>
    <string name="topics_tv17">Data\nStorage</string>
    <string name="topics_tv18">JASON\nParsing</string>


    <string name="introduction_tv1">Introduction</string>
    <string name="introduction_tv2">      Android is a Linux based operating system. It is designed primarily for touch screen mobile devices such as tablet computers and smartphones. The android operating system has developed more in last 15 years starting from black and white phones to recent smartphones or mini computers. \n\n     The android is a powerful operating system and it supports large number of applications in Smartphones and other supportable devices. These applications are more comfortable and advanced for the users. The hardware that supports android software is based on ARM architecture platform.\n\n      The android is an open source operating system it means no license, distribution and development fee and any one can use it. The android has got millions of apps available that can help you managing your life easily and it is available in low prices in market that why android is very popular.\n\n      The android development supports with the full java programming language. Even other packages that are API and JSE are not supported. The first version 1.0 of software development kit (SDK) was released in 2008 and latest updated version is 9.0 with code name of Pie.</string>
    <string name="introduction_tv3">History of Android</string>
    <string name="introduction_tv4">      The code names of android are from A to P at present, such as Aestro, Blender, Cupcake, Donut, Eclair, Froyo, Gingerbread, Honeycomb, Ice Cream Sandwitch, Jelly Bean, KitKat, Lollipop, Marshmallow, Nougat, Oreo and Pie. Let\'s understand the android history below. \n\nAndy Rubin founded Android Incorporation in Palo Alto, California, United States in October, 2003.\n\nGoogle acquired android Incorporation in 17th August 2005. Since then, it is in the subsidiary of Google Incorporation.\n\nThe key employees of Android Incorporation are Andy Rubin, Rich Miner, Chris White and Nick Sears.\n\nAndroid is the nick name of Andy Rubin given by coworkers because of his love to robots. Google announces the development of android OS in 2007.\nThe first phone released that ran the Android OS which is T-Mobile G1.HTC launched the first android mobile in 2008.</string>
    <string name="introduction_tv5">Features of Android</string>
    <string name="introduction_tv6">      As Android is open source and freely available to manufacturers for customization, there are no fixed hardware and software configurations.\n\nHowever, Android itself supports the following features:\n   1. Storage — Uses SQLite, a lightweight relational database, for data storage.\n  2. Connectivity — Supports GSM/EDGE, IDEN, CDMA, EV-DO, UMTS, Bluetooth (includes A2DP and AVRCP), WiFi, LTE, and WiMAX.\n    3. Messaging — Supports both SMS and MMS.\n  4. Web browser — Based on the open-source WebKit, together with Chrome’s V8 JavaScript engine.\n  5. Media support — Includes support for the following media: H.263, H.264 (in 3GP or MP4 container), MPEG-4 SP, AMR, AMR-WB (in 3GP container), AAC, HE-AAC (in MP4 or 3GP container), MP3, MIDI, Ogg Vorbis, WAV, JPEG, PNG, GIF, and BMP.\n  6. Hardware support — Accelerometer Sensor, Camera, Digital Compass, Proximity Sensor, and GPS Multi.\n  7. Multi-touch — Supports multi-touch screens Multi.\n  8. Multi-tasking — Supports multi-tasking applications.\n  9. Flash support — Android 2.3 supports Flash 10.1.\n  10. Tethering — Supports sharing of Internet connections as a wired/wireless hotspot.</string>
    <string name="introduction_tv7">History of Android</string>


    <string name="architecture_tv1">Android Architecture or Android Software Stack</string>
    <string name="architecture_tv2">Linux kernel</string>
    <string name="architecture_tv3">      The android uses the powerful Linux kernel and it supports wide range of hardware drivers. The kernel is the heart of the operating system that manages input and output requests from software. This provides basic system functionalities like process management, memory management, device management like camera, keypad, display etc the kernel handles all the things. The Linux is really good at networking and it is not necessary to interface it to the peripheral hardware. The kernel itself does not interact directly with the user but rather interacts with the shell and other programs as well as with the hard ware devices on the system.</string>
    <string name="architecture_tv4">Android Libraries</string>
    <string name="architecture_tv5">      In addition to a set of standard Java development libraries (providing support for such general purpose tasks as string handling, networking and file manipulation), the Android development environment also includes the Android Libraries. These are a set of Java-based libraries that are specific to Android development. Examples of libraries in this category include the application framework libraries in addition to those that facilitate user interface building, graphics drawing and database access.\n\nA summary of some key core Android libraries available to the Android developer is as follows:</string>
    <string name="architecture_tv6">      1. android.app – Provides access to the application model and is the cornerstone of all Android applications.\n\n    2. android.content – Facilitates content access, publishing and messaging between applications and application components.\n\n    3.android.database – Used to access data published by content providers and includes SQLite database management classes.\n\n    4. android.graphics – A low-level 2D graphics drawing API including colors, points, filters, rectangles and canvases.\n\n    5. android.hardware – Presents an API providing access to hardware such as the accelerometer and light sensor.\n\n  6. android.opengl – A Java interface to the OpenGL ES 3D graphics rendering API.\n\n    7.android.os – Provides applications with access to standard operating system services including messages, system services and inter-process communication.\n\n    8. android.media – Provides classes to enable playback of audio and video.\n\n   9. android.net – A set of APIs providing access to the network stack. Includes android.net.wifi, which provides access to the device’/s wireless stack.\n\n  10. android.print – Includes a set of classes that enable content to be sent to configured printers from within Android applications.\n\n   11. android.provider – A set of convenience classes that provide access to standard Android content provider databases such as those maintained by the calendar and contact applications.\n\n   12.android.text – Used to render and manipulate text on a device display.\n\n  13. android.util – A set of utility classes for performing tasks such as string and number conversion, XML handling and date and time manipulation.\n\n    14. android.view – The fundamental building blocks of application user interfaces.\n\n   15. android.widget - A rich collection of pre-built user interface components such as buttons, labels, list views, layout managers, radio buttons etc.\n\n      Having covered the Java-based libraries in the Android runtime, it is now time to turn our attention to the C/C++ based libraries contained in this layer of the Android software stack.</string>
    <string name="architecture_tv7">C/C++ Libraries</string>
    <string name="architecture_tv8">      The Android runtime core libraries outlined in the preceding section are Java-based and provide the primary APIs for developers writing Android applications. It is important to note, however, that the core libraries do not perform much of the actual work and are, in fact, essentially Java “wrappers” around a set of C/C++ based libraries. When making calls, for example, to the android.opengl library to draw 3D graphics on the device display, the library actually ultimately makes calls to the OpenGL ES C++ library which, in turn, works with the underlying Linux kernel to perform the drawing tasks.\n\n      C/C++ libraries are included to fulfill a wide and diverse range of functions including 2D and 3D graphics drawing, Secure Sockets Layer (SSL) communication, SQLite database management, audio and video playback, bitmap and vector font rendering, display subsystem and graphic layer management and an implementation of the standard C system library (libc).\n\n     In practice, the typical Android application developer will access these libraries solely through the Java based Android core library APIs. In the event that direct access to these libraries is needed, this can be achieved using the Android Native Development Kit (NDK), the purpose of which is to call the native methods of non-Java or Kotlin programming languages (such as C and C++) from within Java code using the Java Native Interface (JNI).</string>
    <string name="architecture_tv9">Android runtime</string>
    <string name="architecture_tv10">      At the same layer as the libraries, the Android runtime provides a set of core libraries that enable developers to write Android apps using the Java programming language. The Android runtime also includes the Dalvik virtual machine, which enables every Android application to run in its own process, with its own instance of the Dalvik virtual machine (Android applications are compiled into the Dalvik executables). Dalvik is a specialized virtual machine designed specifically for Android and optimized for battery-powered mobile devices with limited memory and CPU.</string>
    <string name="architecture_tv11">Android Framework</string>
    <string name="architecture_tv12">      The Application Framework is a set of services that collectively form the environment in which Android applications run and are managed. This framework implements the concept that Android applications are constructed from reusable, interchangeable and replaceable components. This concept is taken a step further in that an application is also able to publish its capabilities along with any corresponding data so that they can be found and reused by other applications.\n\n The Android framework includes the following key services:\n</string>
    <string name="architecture_tv13">      1. Activity Manager – Controls all aspects of the application lifecycle and activity stack.\n\n      2. Content Providers – Allows applications to publish and share data with other applications.\n\n      3. Resource Manager – Provides access to non-code embedded resources such as strings, color settings and user interface layouts.\n\n        4. Notifications Manager – Allows applications to display alerts and notifications to the user.\n\n      5. View System – An extensible set of views used to create application user interfaces.\n\n        6. Package Manager – The system by which applications are able to find out information about other applications currently installed on the device.\n\n      7. Telephony Manager – Provides information to the application about the telephony services available on the device such as status and subscriber information.\n\n      8. Location Manager – Provides access to the location services allowing an application to receive updates about location changes.</string>
    <string name="architecture_tv14">Applications</string>
    <string name="architecture_tv15">      On the top of android framework, there are applications. All applications such as home, contact, settings, games, browsers are using android framework that uses android runtime and libraries. Android runtime and native libraries are using linux kernal.</string>

    <string name="IDE_tv1">Android Studio IDE</string>
    <string name="IDE_tv2">Android Studio is the official Integrated Development Environment (IDE) for Android application development, based on IntelliJ IDEA .</string>
    <string name="IDE_tv3">Manifest Folder: This folder consists of a manifest.xml file which android system requires for all the essential information of the application, like:\n       Package Name : Unique Identifier of the application\n      Components : We have to describe all the components in the application(We will discuss components in upcoming chapters)\n     Permissions : Describe all permission application will require.</string>
    <string name="IDE_tv4">0</string>
    <string name="IDE_tv5">Java Folder : Here you will have all your Java and Kotlin files.\nRes Folder : This folder consists of all the media requirements of application like screen layouts inside the layout, images inside drawable, fonts, colour, strings and dimension will be inside values</string>
    <string name="IDE_tv6">User Interface of IDE</string>
    <string name="IDE_tv7">     1. Toolbar : All necessary actions like copy, paste, find etc. with the run application, open SDK manager and other tools\n     2. Navigation Bar : This shows you the path of the file you are working on\n    3. Editor Window : This is the screen where you have all your files open, and you can write code, design layouts etc. depending upon the file type\n     4.Tool Window Bar : This is the window consists of multiple options which you can expand on clicking on it.\n     5. Tool Window : Here you will see the option you had selected in Tool Window Bar.\n     6. Status Bar : Here you can check your project status.</string>
    <string name="IDE_tv8">Gradle Build System</string>
    <string name="IDE_tv9">     In Android Studio, Gradle is a custom build tool used to build APK files, by managing dependencies and providing custom build logic.\n     APK file (Android Application Package) is a specially formatted zip file which consists of Bytecode, Resources (images, UI, XML etc.)\n     In this chapter, you read about all the initial details of the Android Studio IDE. This IDE consists of many features which will make your journey as an Android Developer more comfortable. We will be going to discuss more features one by one in upcoming chapters.</string>

    <string name="component_tv1">Application Components</string>
    <string name="component_tv2">The android application components or core building blocks are the basic building blocks of an android application and these components will allow system or user to access our app.\n\n The followings are the basic core building blocks of android application components that can be used in Android application:\n    1. Activities\n    2. Intent\n    3. Services\n    4. Broadcast Receivers\n    5. Content providers</string>
    <string name="component_tv3">Activities</string>
    <string name="component_tv4">Activity represents a single screen with a user interface (UI) and it is act as a entry point for users to interact with app.\n\n For example, a contacts app which has multiple activities like displaying a list of contacts, add new contact and another activity shows to search for the contacts in the contacts list of an app. All activities of a contacts app are independent to each other but these activities work together to provide a better user experience.</string>
    <string name="component_tv5">Intents</string>
    <string name="component_tv6">An intent is a messaging object which is used to request an action from another component.\n\nIt is mainly used to perform following things: \n    1. Start an Activity\n    2. Start a Service\n    3. Deliver a Broadcast\n    4. Display a Webpage etc.\n\nThere are two types of intents in android as follows:\n    1. Implicit Intents\n    2. Explicit Intents</string>
    <string name="component_tv7">Services</string>
    <string name="component_tv8">Service is a component which is a background process to perform long running operations based on our requirements. Service have not any user interface(UI) and it can run the apps in background for a long time like play music in background when the user in different app.\n\nWe have two types of services available in android as follows:\n    1. Local Services\n    2. Remote Services\n\nLocal service is a service which is accessed from within the application whereas remote service is a service which is accessed remotely from other applications running on the same device.</string>
    <string name="component_tv9">Broadcast Receivers</string>
    <string name="component_tv10">Broadcast Receivers is a component which allows a system to deliver events to the app like listening for Incoming call, sms, sending a low battery message to the app etc. The apps can also initiate broadcasts to let other apps know that required data available in a device to use it. It is used to handle communication between Android operating system and applications.\n\nGenerally, we use Intents to deliver broadcast events to other applications and Broadcast Receivers use status bar notifications to let user know that broadcast event occurs</string>
    <string name="component_tv11">Content Providers</string>
    <string name="component_tv12">Content Providers are used to exchange the data between the applications based on the requests. The Content Providers can share the app data that store in the file system, SQLite Database, on the web or any other storage location that our application can access. \n\nBy using Content Providers, other applications can query or modify the data of our application based on the permissions provided by content providers. For example, android provides a Content Provider (ContactsContract.Data) to manage contacts information, by using proper permissions any app can query the content provider to perform read and write operations on contacts information.</string>

    <string name="manifest_tv1">Manifest File</string>
    <string name="manifest_tv2">Today, I would like to help you understand the Android Application Manifest File as an android developer. Each android application you build will include a file called AndroidManifest.xml which is placed in the root of the project hierarchy. So why is it important? Because it lets you define the structure and metadata of your android application and its components.\n\nThe Android Application Manifest file includes nodes for each of the following components:\n    1. Activities\n    2. Services\n    3. Content providers\n    4. Broadcast Receivers\n\n that make up your application and uses Intent Filters and Permissions to determine how they interact with each other and other applications. It also offers you attributes that you can use to specify application metadata like icon and theme among other things.\n\n The Android Application Manifest file is made up of a root manifest tag with a package attribute set to the project’s package. It normally includes an xmlns:android attribute that supplies several system attributes used within the android application manifest file.</string>
    <string name="manifest_tv3">Android Application Manifest Node Tags</string>
    <string name="manifest_tv4">1. application : A manifest can contain only one application node. This uses attributes to specify the metadata for your android application(title, icon and theme). Besides that, it acts as a container that includes the Activity, Service, Content Provider and Broadcast Receiver tags for specifying the application components:\n\n     Activity : For every activity displayed by your android application, an activity tag is required. You set it using android:name attribute to specify the class name. It must include the main launch Activity and any other screen or dialog that can be displayed. If you try to start an Activity that is not defined, you will get a runtime exception. Each Activity node supports intent-filter child tags which specify which Intents launch the activity.\n\n     Service : Just like the activity tag, you must create a new service for each Service class used inside your application. Service tags also support intent-filter child tags to allow late runtime binding.\n\n     Provider : provider tags are used for each of your application Content Providers. Content Providers are used to manage database access and sharing within and between applications.\n\n     Receiver : You can register a Broadcast Receiver by adding a receiver tag without having to launch your application first. Broadcast Receivers are more like global event listeners – once registered, they will execute whenever a matching Intent is broadcast by an application.</string>
    <string name="manifest_tv5">2. Uses - Permission :  this is part of the security model. It declares permissions you have determined that your application needs to operate properly. The permissions you include will always be presented to the user to either grant or deny during installation. Many native android services require permissions for example those that have cost or security implications. Examples : location services, SMS etc.</string>
    <string name="manifest_tv6">3. Permission : You need to define a permission in the android application manifest file before restricting access to any application component. Use the permission tag to create the permission definitions. The application components can then require them by adding the android:permission attribute. Other apps will then need to include a uses-permission tag in their manifest file and have it granted before they can use these protected components.\n\n Within the permission tag you can specify the level of access the permission will permit( normal, dangerous, signature, signatureOrSystem), a label, and an external resource containing the description that explains the risks of granting this permission.</string>
    <string name="manifest_tv7">4. Instrumentation :  Instrumentation classes provide a framework for running tests on your Activities and Services at run time. They simply provide hooks to monitor your application and its interaction with the system resources. You must create a new node for each of the test classes you have created in your application.</string>

    <string name="activity_tv1">Android Activities</string>
    <string name="activity_tv2">One of the core building block of Android app development is an Activity. It is represents a single screen with user interface(UI). ContextThemeWrapper is the super class of an activity. Activity is the main entry point of an Android app just like main method of a program written in Java or C++. An activity interacts with user so it creates a window to place UI elements. An Android application can contain several activities means many different screens represents that can interact with each other and independently with the user.</string>
    <string name="activity_tv3">Android Activity Lifecycle</string>
    <string name="activity_tv4">Android activity has its own life cycle during its life it can perform many operations. Android activities are stored and managed in a stack called activity stack. New activity comes at the top of stack and becomes running, while previous remains below to the new activity in stack. When the top activity in the stack exits, the lower to the top becomes active.</string>
    <string name="activity_tv5">States of Android activity</string>
    <string name="activity_tv6">Running : An activity is in running state when an acitivity at the top of the stack is in running or active state means it is at the foreground of the screen.\n\n Paused : An activity is paused state when an activity is alive but it is not focused in the paused state. (This is as a pop-up message shown on the activity).\n\n Resumed : An activity is resumed state When a paused activity becomes active it is refreshed and started again.\n\n Stopped : An activity is stopped state when an activity is no longer visible on the screen to the user is in the stopped state.</string>
    <string name="activity_tv7">Android activity call back methods</string>
    <string name="activity_tv8">An activity implements following call back methods :\n\n     OnCreate(): This is first call back method of an android activity. It is called when an activity is created. This is where all you set all stuffs like Button, Views, Checkbox, TextView etc.\n\n     OnStart() — It is second call back nethod. It is called when the activity is visible on the screen to the user.\n\n     OnResume() — This is called after OnStart() method if the activity comes to foreground. This is when user starts interacting with the activity.\n\n     OnPause() — This is followed by OnResume(). This method is called when a previous activity is resumed.\n\n     OnStop() — It is called when another activity is resumed then this activity is no longer visible to user. It becomes hidden.\n\n     OnDestroy() — This is the final call back method when the activity is finished.\n\n     OnRestart()?—?It is called when an activity restarts.</string>

    <string name="fragment_tv1">Android Fragments</string>
    <string name="fragment_tv2">An Android Fragment is a piece of an activity which enable more modular activity design. It will not be wrong if we can say that a fragment is a kind of sub-activity. In an Android Activity used for creating dynamic and flexible user interface(UI). An Android Fragment has its own life cycle but it always be embedded with an activity so that the android fragments life cycle is directly affected by the host activities life cycle and android fragments receives its own input events. In android application we can use multiple android fragments in a single activity of an application to create Multi-Pane user interface(UI) and also we can able to use a single fragment in multiple activities . Now, Fragment Manager is responsible for add or remove or replace fragments at run time in any where of an activity.when we add a fragment in an activity it lives in a ViewGroup in side the activities view hierarchy and fragment defines its own view layout by declaring the fragment in the activities layout file as a element or from application code by adding it to an existing ViewGroup.</string>
    <string name="fragment_tv3">There are some points about android fragments:\n\n     1. A fragment has its behaviour and its layout with its lifecycle callbacks methods.\n\n     2.You can add or remove fragments in the activity. When activity is running, which is in the resumed lifecycle state.\n\n     3. You can also combine multiple fragments in a single activity to make a multi-pane user interface(UI).\n\n     4. And it provides reusability of a fragment in multiple activities.\n\n     5. A fragment life cycle is very closely related to the lifecycle of its host activity which means when the activity is in the pause state, all the fragments available in the activity will also stop.\n\n     6. Fragments added to the Android API in Android 3.0 which API version 11 to support flexible user interface(UI) on large screens devices.</string>
    <string name="fragment_tv4">Below are the subclasses of a Fragmnt Class :\n\n     1. ListFragment\n     2. DialogFragment\n     3. PreferenceFragment\n     4. WebViewFragment\n\n ListFragment\n          ListFragment is similar to ListActivity and contains a ListView by default. It purpose for displaying a list of items. We used ListFragment; see the Creating and managing fragments section for ListFragment.\n\n DialogFragment\n          A DialogFragment displays a dialog on top of its owner activity. We are create a fragment that has a Delete button. When the button is clicked, a DialogFragment dialog box will be displayed.\n\n PreferenceFragment\n          PreferenceFragment contains a hierarchy of preference objects as the lists. These preferences will automatically save to sharedPreferences as the user interacts with them. To retrieve an instance of SharedPreferences that the preference hierarchy in this fragment will use, call PreferenceManager.getDefaultSharedPreferences(android.content.Context) with a context in the same package as this fragment.\n\n WebViewFragment\n          WebView can also assist with common browsing metaphors, such as the list of visited URLs history to support backwards and forwards navigation. Still WebView comes with its own set of cons such as its a much more expensive widget to use, in terms of like memory consumption than a TextView. The reason for memory increased is because WebView is powered by WebKit/Blink that are open source Web rendering engine to power content in browsers like Chrome.</string>
    <string name="fragment_tv5">Android Fragments Life Cycle</string>
    <string name="fragment_tv6">The following are the Android Fragments Life Cycle</string>
    <string name="fragment_tv7">Below are the android fragments lifecycle callbacks :\n\nonAttach()\n          This method is called first even before onCreate() callback methods and after attaching fragment to the activity. if Android SDK Version(API Level 23) it takes an activity as a reference that will host the fragment else it takes Context as a reference. By using this reference we can obtain system services and initialize fragment interactive events etc.\n\nonCreate()\n          This method is called when creating the fragment and it takes Bundle as a reference which is used for initialize the necessary components and store its value that you want to retain when the fragment is paused or stopped state, then resumed.when the fragment is implemented for the first time in the activity Bundle object is null.\n\nonCreateView()\n          In this method when the fragment is added to an activity for the first time.you must return a view from this method that is the root of your fragments layout. If the fragment does not provide a user interface(UI) the you can return null.\n\nonActivityCreated()\n          This method is called after Activity onCreate() callback has completed its execution. And this method is an indication for the activity has complete its execution before we try to access without any interruption and modify user interface(UI) elements of the activity.\n\nonStart()\n          This method is called once the android fragment gets visible in the activity after activity onStart() callback.\n\nonResume()\n          This method is called when the user interacting with the android fragments in the activity after activity onResume() callback.\n\nIf we are no longer being used a fragment, it goes through a reverse series of callbacks.\n\nonPause()\n          This method is called when the fragment is no longer being used to interact with the user either because its activity is being paused state or a fragment operation is modifying it in the activity.\n\nonStop()\n          This method is called when the fragment is no longer being used to interact with the user either because its activity is being stopped state or a fragment operation is modifying it in the activity.\n\nonDestroyView()\n          This method is called to allow the fragment to cleanup resources associated with its view in the activity.\n\nonDestroy()\n          This method is called to do final cleanup of the fragments state.\n\nonDetach()\n          This method is called to the fragment no longer being associated with its activity.\n\n Key Notes\nNormally, you should implement at least the following life cycle callbacks methods : \n          1. onCreate()\n          2. onCreateView()\n          \nonPause()\n\nBy the host activity we can save each Fragment Transaction to a Back Stack manged and the user allows to reverse a fragment transaction by this back stack.\n\nIn case if we have a method with the same name in both the activity and fragment during the creation phase the activitys method runs first and the fragments method runs next.</string>
    <string name="fragment_tv8">onSaveInstaceState() : </string>
    <string name="fragment_tv9">This callback is called where you allowed to save some data about fragment events just before the app is paused state so that when the user comes back to the app they get the saved data. Here it takes Bundle reference so we can able to store data as (key,value) pairs.</string>


    <string name="uilayout_tv1">Android UI Layouts</string>
    <string name="uilayout_tv2">    The basic building block for android user interface(UI) is a View object which is created from the View class and it is occupied in rectangular area on the screen and it is responsible for interacting with user, drawing and event handling. View is the base class for widgets, which are used to create interactive user interface(UI) components like buttons, check box, text fields, etc.</string>
    <string name="uilayout_tv3">Views and ViewGroups</string>
    <string name="uilayout_tv4">    An Activity contains Views and ViewGroups. In android a View is a widget that visible on screen. Examples of widgets are buttons, labels, check box, text boxes, etc. A View derives from the base class android.view.View. The ViewGroup is a subclass of View and it provides invisible container that hold the other Views or the other ViewGroups and define their layout properties.</string>
    <string name="uilayout_tv5">    At third stage we have different layouts which are subclasses of ViewGroup class and for an user interface(UI) a typical layout defines the visual structure and can be created either at run time using View or ViewGroup objects or you can also declare your layout using simple XML file activity_main_layout.xml which is located in the res/layout folder of your project.</string>
    <string name="uilayout_tv6">Layouts</string>
    <string name="uilayout_tv7">    Android user interface(UI) Layout in which you can use in almost all the Android applications to provide different view, look and feel. The  seven different  Layouts are:-</string>
    <string name="uilayout_tv8">
    1.Linear Layout
    2.Relative Layout
    3.Absolute Layout
    4.Table Layout
    5.Frame Layout
    6.List view
    7.Grid view</string>
    <string name="uilayout_tv9">1.Linear Layout</string>
    <string name="uilayout_tv10">In Android a LinearLayout is a view group that aligns all the children in a single direction may be horizontally or vertically. And it also supports assigning a weight to individual children with the android:layout_weight attribute. Either Horizontally or Vertically orientation and this behavior is set in android:orientation which is an attribute of the node LinearLayout.</string>
    <string name="uilayout_tv11">Horizontal layout xml snippet</string>
    <string name="uilayout_tv12">  horizontal Layout Snippet code</string>
    <string name="uilayout_tv13">  Vertical layout xml snippet</string>
    <string name="uilayout_tv14">  Vertical Layout Snippet code </string>
    <string name="uilayout_tv15">2.Relative Layout</string>
    <string name="uilayout_tv16">RelativeLayout is a view group which specifies how child views are positioned relatively to each other. Then each view positioned as relative to sibling elements. you can use like some attributes "below, above, right and left" to arrange the component position.</string>
    <string name="uilayout_tv17">RelativeLayout xml snippet</string>
    <string name="uilayout_tv18">RelativeLayout xml snippet code </string>
    <string name="uilayout_tv19">3.Table Layout</string>
    <string name="uilayout_tv20">TableLayout is a layout which groups views into rows and columns.
And it is very easy to understand.</string>
    <string name="uilayout_tv21">Table Layout xml snippet</string>
    <string name="uilayout_tv22">Table Layout xml snippet code </string>
    <string name="uilayout_tv23">4.Absolute Layout</string>
    <string name="uilayout_tv24">AbsoluteLayout is a layout which allows you to specify the exact location of its children. It is less flexible and harder to maintain than other types of layouts without absolute positioning.</string>
    <string name="uilayout_tv25">Absolute Layout xml snippet</string>
    <string name="uilayout_tv26">Absolute  Layout xml snippet code </string>
    <string name="uilayout_tv27">5.Frame Layout</string>
    <string name="uilayout_tv28">The FrameLayout is a layout in which a placeholder on a screen that you can use to display a single view.</string>
    <string name="uilayout_tv29">FrameLayout xml snippet</string>
    <string name="uilayout_tv30">Frame  Layout xml snippet code </string>
    <string name="uilayout_tv31">6.ListView</string>
    <string name="uilayout_tv32">Listview is a view group that displays a list of scrollable items on a screen. The list items are automatically inserted to the list using an adapter that pulls the content from a source such as an array or database query and converts each item result into a view that\'s placed into the list.</string>
    <string name="uilayout_tv33">ListView xml snippet</string>
    <string name="uilayout_tv34">List View xml snippet code </string>

    <string name="services_tv1">Services</string>
    <string name="services_tv2">Service in android is a component which is a background process to perform long running operations based on our requirements such as playing music, handle network transactions, interacting content providers etc.The service runs in the background indefinitely even if application is destroyed.\n\nAdditionally, a service component can bind to a service to perform interactivity and inter process communication (IPC).\n\nService have not any user interface(UI) and it can run the apps in background for a long time like play music in background when the user in different app. Now, services are classified into two types : \n\n           1. Local : This service is accessed from within the application.\n           2. Remote – This service is accessed remotely from other applications running on the same device.\n\nService is implemented as a subclass of Service class as follows :</string>
    <string name="services_tv3">Note: Android service is not just like a thread or separate process.</string>
    <string name="services_tv4">Android Service Life Cycle</string>
    <string name="services_tv5">The life cycle of android service will follow two different paths Started or Bound.</string>
    <string name="services_tv6">Started Service</string>
    <string name="services_tv7">A service is started in android when an application component, such as an activity is calling startService() method. Once it started, it will run indefinitely in background even if the component that started is destroyed.\n\nAnd we can stop the started service by calling stopService() method or the service can stop itself by calling stopSelf()method. In android, the Started service component performs a single operation and it won’t return any result to the caller. This service is also known as the Unbounded service.</string>
    <string name="services_tv8">Bound Service</string>
    <string name="services_tv9">A service is Bound in android when another application component is calling bindService() method. The bound service will run as long as another application component is bound to it. \n\nAnd we can unbind the service by calling unbindService() method based on our requirements. In android, we can bind multiple components to single service at once, but the service will be destroyed in case all the components unbind.</string>
    <string name="services_tv10">Android Services Lifecyle Diagram</string>
    <string name="services_tv11">Below diagram shows the lifecycle of Started service, when the service created with startService() method and the lifecycle of Bound service, when the service created with bindService() method.</string>
    <string name="services_tv12">To create a service, we need to create a class that extends a Service base class or one of its existing subclasses. When we want implement our service, we must need to override the some of callback methods that handle the key aspects of android service lifecycle and provide the functionality which allows our components to bind to the service.</string>
    <string name="services_tv13">Creating a Service</string>
    <string name="services_tv14">To create service we will create a java class extending the class service base class or one of its existing subclasses. The service base class defines various type of callback methods that is given below. And we should override the following methods.</string>
    <string name="services_tv15">Callback Methods\n\nonStartCommand()</string>
    <string name="services_tv16">This method is invoked when the service is started by calling the startService() method. We can call the method startService() method from any activity and it will request the service to start.\nWhen this method is executed, the service will start and run indefinitely in background. And we implement this in our code, it is our responsibility to stop this service once the code execution is done by calling stopSelf() or stopService() methods. But, if we want to provide only binding, then we don not need to implement this method. \n\nNow in android service, onStartCommand() method must return an integer and the integer is a value that describe how the system will continue the service in the event that the system kills it. The onStartCommand() method will return a value from one of the following constants.</string>
    <string name="services_tv17">onBind()</string>
    <string name="services_tv18">This method is invoked when If it is needed to override this method, only if you are defining your service as bounded service. This method is called, when another component wants to bind with the service by calling bindService(). In your code you want to implement of this method, you must provide an interface that clients use to communicate with the service, by returning an IBinder. You must always implement this method, but if you don’t want to bind the service with an activity then you should return null on this method.</string>
    <string name="services_tv19">onCreate()</string>
    <string name="services_tv20">This method is invoked when it is called the service is created at the beginning using onStartCommand() or onBind() methods to do one time setup procedures. If the service is already running, then this method will not call.</string>
    <string name="services_tv21">onDestroy()</string>
    <string name="services_tv22">This method is invoked when the service is no longer used and destroyed this method. Your service implement this method in our service to clean up any unused resources such as threads,  registered liteners, receivers or listeners. This is the last call that the service receives. In android service if we start a service by calling startService() method, the service will run continuously even if the component that started a service is destroyed until we stop it by using stopService() or it stops itself with stopSelf().\n\nsimilarly we create a service by calling bindService() method, the service will runs as long as the android component is bound to it. Subsequently the service is unbound from all of its clients, the system will destroys it. \n\nNow, the service life cycle is having a set of callback methods that need to be implemented to keep a track of services status and to execute the required things in appropriate time.</string>

    <string name="broadcast_receiver_tv1">Broadcast Receivers</string>
    <string name="broadcast_receiver_tv2">Broadcast Receivers is a component which allows a system to deliver events to the app like listening for Incoming call, sms, sending a low battery message to the app etc. The apps can also initiate broadcasts to let other apps know that required data available in a device to use it.It is used to handle communication between Android operating system and applications.\n\n  Generally, we use Intents to deliver broadcast events to other applications and Broadcast Receivers use status bar notifications to let user know that broadcast event occurs.</string>
    <string name="broadcast_receiver_tv3">Types of Broadcast Receivers</string>
    <string name="broadcast_receiver_tv4">There are two types of broadcasts received by receivers and they are:</string>
    <string name="broadcast_receiver_tv5">1. Normal Broadcasts </string>
    <string name="broadcast_receiver_tv6">      It is efficient.\n      Receivers cannot use the result.\n       They can not abort the included APIs.\n       These are asynchronous broadcasts.\n       Receivers of this type of broadcasts may run in any order, sometimes altogether.\n      These broadcasts are sent with Context.sendBroadcast.</string>
    <string name="broadcast_receiver_tv7">2. Ordered Broadcasts </string>
    <string name="broadcast_receiver_tv8">      At a time only one broadcast is delivered to one receiver.\n        Receivers can use the result. In fact as each receiver executes, result is passed to next receiver.\n       Receiver can also abort the broadcast and hence no broadcast is received by other receivers.\n      These are synchronous broadcasts.\n         The order of receivers is managed and controlled by the attribute android:priority in corresponding intent-filter. \n       If the receivers will have same priority then they may run in any order. </string>
    <string name="broadcast_receiver_tv9">Benefits of Broadcast Receiver</string>
    <string name="broadcast_receiver_tv10">Broadcast Receiver do not have UI but can start an Activity.\n      A Broadcast receiver wakes your application up, the inline code works only when your application is running.\n      Broadcast Receiver has maximum limit of 10secs, don not do any asynchronous operations which may take more time, don not do heavy database operations or networking operations in broadcast receiver.</string>

    <string name="androidmenu_tv1">Android Menu</string>
    <string name="androidmenu_tv2">In android it provides an easy, flexible and common user interface(UI) component known as menu, which is used to handle a set of actions. Menu is a set of options, the user can select to perform an action . Android menu provide a familiar and consistent user experience ain entire the application. Based upon the menu item clicked, a certain action can be performed by the application such as add, search, delete, update, edit, or refresh etc. Android menu comes from Android 3.0 (API level 11).\n\n There are 3 types of menus in android: \n\n      1.Option Menu \n      2.Context Menu \n      3.Popup Menu</string>
    <string name="androidmenu_tv3">1. Option Menu:</string>
    <string name="androidmenu_tv4">Android option menu is the primary collection of menu items for an activity. It is the place where we implement the actions that have a global impact on the app, such as Add,Search, , Modify, Settings and Delete. Option menu appears in the app bar and provides the primary options to the user.</string>
    <string name="androidmenu_tv5">2. Context Menu:</string>
    <string name="androidmenu_tv6">Context menu provides a set of menu options when user perform long click on an element on a screen of the application. Most often context menu is used for items in ListView, GridView, RecyclerView or other view collections in which the user can perform direct actions on each item.\n\n Android provides two different way of context menu :- \n       Floating Menu \n        Contextual action mode or Contextual action bar</string>
    <string name="androidmenu_tv7"> Floating Menu:</string>
    <string name="androidmenu_tv8">A floating menu is menu that appears when the user performs a long-click on an element. It provides the actions that affect the selected content or a view element on the screen. It provides a floating list of menu items when the user performs a long tap on an item.</string>
    <string name="androidmenu_tv9"> Contextual Action Bar:</string>
    <string name="androidmenu_tv10">A contextual action bar appears at the top of the screen in place of the app bar or underneath the app bar, with action items that affect the selected view element(s) in android application. When a user enables this mode by selecting an item, a contextual action bar appears at the top of the screen to present actions the user can perform on the currently selected item(s).</string>
    <string name="androidmenu_tv11">3. PopUp Menu:</string>
    <string name="androidmenu_tv12">A popup menu displays a list of items in a vertical list that’s anchored(sticked) to the view that invoked the menu. Popup menu provides an overflow-style menu for actions that relate to specific content (such as Gmail’s email headers) or to provide options for a second part of a command.</string>

    <string name="intent_tv1">Android Intent</string>
    <string name="intent_tv2">An Intent is a messaging object that you can use to stimulate a component of an application . Intents grant you to interact with components that belong either at the same application or outside that application. It is an abstract description of an operation to be performed. The Intent object contains information which is used either from the components that receive that intent or the Android system itself.\n\nIntent can be used to:\n          1. To start an activity\n          2. To start a service\n          3. To deliver a broadcast\n          4. Display a webpage etc.\n\nIntent Objects\n          An intent object is a bundle of information that is used by the android component that receives the intent as well as information that is used by the android system.\n\nIntent objects contains the following things :\n\n Component name : This information is optional. If the component name is set, then the Android system directly maps the intent to the target component. Else the android system utilizes other information to locate the suitable target. The component name is set by setComponent (), setClass () and is read by getComponent ().\n\n Action : This is necessary part of information names the action an Android component should take on receiving the Intent , or is being notified to the system and the action that has already taken place. The Android system defines a number of Action Constants.\n\n    here is some of common actions are :</string>
    <string name="intent_tv3">This action is invoked in an intent with  startActivity(), when we have information in which an activity can show to the user.</string>
    <string name="intent_tv4">This action is invoked in an intent with startActivity(), when we have a some data in which the user can share through another app such as social sharing app, email app etc.</string>
    <string name="intent_tv5">Data: it contains the Uniform Resource Identifier (URI) of the data. There are different types of data blueprint for different actions. For instance, if the action defined were ACTION_CALL, the data field would contain a number to call (tel: URI). For correctly matching the Intent to a applicable component and defining the data type (in addition to the URI) helps. And, a component to display image should be called to display image only, not to play an audio file.\n\nCategory: This category is optional part and it defines the category of the component that is handle by the Intent.\n\nExtras: This is the "key value pair" for further information that needs delivered to the component handling the intent.\n\nFlags : This flags are defined in the intent class that function as metadata for the intent and the flags may instruct the Android system to launch an activity in a specific manner.\n\nIntents can be divided into two types:\n          Explicit intents - An explicit intent is the type of an intent in which you explicitly define the component that needs to be called by the Android System. Generally, explicit intents are used to start components within your own application.\n        To Create Explicit Intent :</string>
    <string name="intent_tv6">Implicit intents - The implicit intent is the type of an intent where instead of defining the exact components where you have to define the action that you want to perform for different activities.\n\n          To Create Implicit Intent :</string>
    <string name="intent_tv7">Intent filters</string>
    <string name="intent_tv8">An Android intent filter is an expression. It is expressed in the manifest file of an andoid application. It defines the type of intent the component need to receive. Android Os uses filters to pinpoint the set of activities, services, and broadcast receivers that can handle the intent with the help of specified set of action categories, data, scheme associated with an intent.For an implicit intent, intent filter is required. If there is no intent filter for an activity, then only an explicit intent can initiate it.\n\nFor security reasons, the intent filter can not be used for the service. Service may start without notifying the user and runs in the background. Android architecture in your device will find the component declared in an intent filter and search for it in entire android application. When we found, it starts respective activity and performs the appropriate action to that.\n\nIn android a component has separate filters for each task it can do, each face it can show to the user. For example - the NoteEditor activity of the sample notepad application has two filters i.e — one for starting up with a specific note that the user can view or edit, and for another, starting with a new, blank note that the user can fill in and save.</string>
    <string name="intent_tv9">Syntax: intent-filter</string>

    <string name="provider_tv1">Content Provider</string>
    <string name="provider_tv2">In android a Content Provider component exchange the data from one application to others application on request. Such type of requests are handled by the methods of the ContentResolver class. In every application, by default, has an unique Id and different storage path in OS for security purposes and they run on different processes. This is called App Sandbox. A content provider can use different ways to store its data and the data can be stored in files, in a database or even over a network.\n\nWhat content provider does is abstraction to inter-process communication.\n\nThere is four basic operations in Content Providers, generally called CRUD-operations. CRUD is the acronym for create, read, update and delete. And those objects simply represent the data as most often a record of a database, but they could also be an image on your SD-card or a video on the web.\n\nImplemention of a content provider involves always the following steps: \n\n   1. Create a class that extends ContentProvider \n   2. Create a contract class \n   3. Create the UriMatcher definition \n   4. Implement the onCreate() method \n   5. Implement the getType() method \n   6. Implement the CRUD methods \n   7. Add the content provider to your AndroidManifest.xml
</string>
    <string name="provider_tv3">Syntax</string>
    <string name="provider_tv4"></string>
    <string name="provider_tv5">Content URI\n</string>
    <string name="provider_tv6">A content URI is a URI that identifies the data in a provider. Content URI is a unique resource identifier that content provider app provides for client app to access it’s shared data. The content URI format is like below. \n</string>
    <string name="provider_tv7">schema://authority/path \n</string>
    <string name="provider_tv8">   1. schema: </string>
    <string name="provider_tv9">     Schema is the content URI protocol, and it’s value is content in general.</string>
    <string name="provider_tv10">   2. authority: </string>
    <string name="provider_tv11">     This part is used to distinguish different content provider application to avoid conflict issues, so normally it is the application package name.</string>
    <string name="provider_tv12">   3. path: </string>
    <string name="provider_tv13">     This part is used to distinguish different shared data in one android content provider application. Different path will return different data.\n</string>
    <string name="provider_tv14">1. ContentResolver\n</string>
    <string name="provider_tv15">Each android application can be a content provider. For example, android phone contacts, short message system and android media library etc. \n\nTo get data from a content provider, you have to need to use a ContentResolver instance in your app. Normally the ContentResolver instance can be grabbed by Activity‘s getContentResolver() method\n</string>
    <string name="provider_tv16">code snippet</string>
    <string name="provider_tv17">Then you can invoke ContentResolver‘s method to insert, delete, update and query data that another content provider shared. And it is just something like SQLite  database operation.\n\nREAD :   How To Update Delete Android Contacts Programmatically.\n</string>
    <string name="provider_tv18">2. ContentResolver Methods\n</string>
    <string name="provider_tv19">Before processing the data operation in content provider, you should first get the content provider URI instance using below method.\n</string>
    <string name="provider_tv20">code snippet</string>
    <string name="provider_tv21">2.1 Insert Data To Content Provider</string>
    <string name="provider_tv22">insert(Uri providerUri, ContentValues contentvalues)</string>
    <string name="provider_tv23">code snippet</string>
    <string name="provider_tv24">2.2 Update Content Provider Data</string>
    <string name="provider_tv25">update(Uri providerUri, ContentValues contentvalues, String whereClause, String conditionValueArr[]\n</string>
    <string name="provider_tv26">code snippet</string>
    <string name="provider_tv27">2.3 Delete Content Provider Data</string>
    <string name="provider_tv28">delete(Uri providerUri, String whereClause, String conditionValueArr[])\n</string>
    <string name="provider_tv29">code snippet</string>
    <string name="provider_tv30">2.4 Query Content Provider Data</string>
    <string name="provider_tv31">query(Uri uri, String columnArray[], String whereClause, String wherePlaceHolderValue[], String orderByClause)\n\nThe query method return\na android.database.Cursor object, but if it is not null means its not empty, then use \nit’s moveToFirst() method to move to the first row.\n\nThen loop in the cursor to get each row use it’s moveToNext()method</string>



</resources>
